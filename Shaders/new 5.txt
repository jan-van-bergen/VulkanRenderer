#version 450

layout(location = 0) in vec2 in_uv;

layout(location = 0) out vec4 out_colour;

layout(binding = 0) uniform UBO {
	vec3 camera_top_left_corner;
	vec3 camera_x;
	vec3 camera_y;
	
	vec3 sunDirection;
};

const float e  = 2.718281828459045235360287471352662497757247f;
const float pi = 3.141592653589793238462643383279502884197169f;

const float n = 1.0003;   // refractive index of air
const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)
const float pn = 0.035;	  // depolatization factor for standard air

// wavelength of used primaries, according to preetham
const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);

// mie stuff
const vec3  K = vec3(0.686f, 0.678f, 0.666f);
const float v = 4.0f;

// optical length at zenith for molecules
const float rayleighZenithLength = 8.4E3;
const float mieZenithLength = 1.25E3;
const vec3 up = vec3(0, 1, 0);

const float E = 1000.0f;
const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324f;

// earth shadow hack
const float cutoffAngle = pi/2.0f;
const float steepness = 0.5f;

const vec3 primaryWavelengths = vec3(680E-9, 550E-9, 450E-9);

const float turbidity = 1;
const float mieCoefficient = 0.005f;
const float mieDirectionalG = 0.80f;

/**
 * Compute total rayleigh coefficient for a set of wavelengths (usually
 * the tree primaries)
 * @param lambda wavelength in m
 */
vec3 totalRayleigh(vec3 lambda)
{
	return (8 * pow(pi, 3) * pow(pow(n, 2) - 1, 2) * (6 + 3 * pn)) / (3 * N * pow(lambda, vec3(4)) * (6 - 7 * pn));
}

/** Reileight phase function as a function of cos(theta)
 */
float rayleighPhase(float cosTheta)
{
	/**
	 * NOTE: There are a few scale factors for the phase funtion
	 * (1) as given bei Preetham, normalized over the sphere with 4pi sr
	 * (2) normalized to integral = 1
	 * (3) nasa: integrates to 9pi / 4, looks best
	 */
	 
//	return (3.0f / (16.0f*pi)) * (1.0f + pow(cosTheta, 2));
//	return (1.0f / (3.0f*pi)) * (1.0f + pow(cosTheta, 2));
	return (3.0f / 4.0f) * (1.0f + pow(cosTheta, 2));
}

/**
 * total mie scattering coefficient
 * @param lambda set of wavelengths in m
 * @param K corresponding scattering param
 * @param T turbidity, somewhere in the range of 0 to 20
 */
vec3 totalMie(vec3 lambda, vec3 K, float T)
{
	// not the formula given py Preetham.
	float c = (0.2f * T ) * 10E-18;
	return 0.434 * c * pi * pow((2 * pi) / lambda, vec3(v - 2)) * K;
}


/**
 * Henyey-Greenstein approximation as a function of cos(theta)
 * @param cosTheta 
 * @param g goemetric constant that defines the shape of the ellipse.
 */
float hgPhase(float cosTheta, float g)
{
	return (1.0f / (4.0f*pi)) * ((1.0f - pow(g, 2)) / pow(1.0f - 2.0f*g*cosTheta + pow(g, 2), 1.5));
}

float sunIntensity(float zenithAngleCos)
{
//	return E;
	return E * max(0.0f, 1.0f - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));
}

/**
 * log luminance according to a formula from wikipedia
 * http://en.wikipedia.org/wiki/Luminance_(relative)
 */
float logLuminance(vec4 c)
{
//	return 0.0f;
	return log(c.r * 0.2126f + c.g * 0.7152f + c.b * 0.0722f);
}

void main() {
	vec3 direction = normalize(camera_top_left_corner +
		in_uv.x * camera_x +
		in_uv.y * camera_y 
	);
	
	// Cos Angles
	float cosViewSunAngle = dot(direction, sunDirection);
	float cosSunUpAngle = dot(sunDirection, up);
	float cosUpViewAngle = dot(up, direction);
	if (sunAngularDiameterCos == 1.0f) {
		out_colour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
		
		return;
	}
	
	float sunE = sunIntensity(cosSunUpAngle); // Get sun intensity based on how high in
		// the sky it is extinction (asorbtion + out
		// scattering) rayleigh coeficients
	vec3 rayleighAtX = vec3(5.176821E-6f, 1.2785348E-5f, 2.8530756E-5f);

	// mie coefficients
	vec3 mieAtX = totalMie(primaryWavelengths, K, turbidity) * mieCoefficient;

	// optical length
	// cutoff angle at 90 to avoid singularity in next formula.
	float zenithAngle = max(0.0f, cosUpViewAngle);

	float rayleighOpticalLength = rayleighZenithLength / zenithAngle;
	float mieOpticalLength = mieZenithLength / zenithAngle;

	// combined extinction factor
	vec3 Fex = exp(-(rayleighAtX * rayleighOpticalLength + mieAtX * mieOpticalLength));

	// in scattering
	vec3 rayleighXtoEye = rayleighAtX * rayleighPhase(cosViewSunAngle);
	vec3 mieXtoEye = mieAtX * hgPhase(cosViewSunAngle, mieDirectionalG);

	vec3 totalLightAtX = rayleighAtX + mieAtX;
	vec3 lightFromXtoEye = rayleighXtoEye + mieXtoEye;

	vec3 somethingElse = sunE * (lightFromXtoEye / totalLightAtX);

	vec3 sky = somethingElse * (1.0f - Fex);
	sky *= mix(vec3(1.0f), pow(somethingElse * Fex, vec3(0.5f)),
					clamp(pow(1.0f - dot(up, sunDirection), 5.0f), 0.0f, 1.0f));

	// composition + solar disc
	float sundisk = smoothstep(
		sunAngularDiameterCos, sunAngularDiameterCos + 0.00002f, cosViewSunAngle);
	vec3 sun = (sunE * 19000.0f * Fex) * sundisk * 1E-5f;

	out_colour = vec4(1,0,1,1); / vec4(sun + sky, 1.0f);
}
